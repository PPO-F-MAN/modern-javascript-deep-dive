## 06장 데이터 타입

> 자바스크립트의 모든 값은 데이터 타입을 갖는다.

| 구분      | 데이터 타입       | 설명                                                |
| --------- | ----------------- | --------------------------------------------------- |
| 원시 타입 | 숫자 타입         | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
|           | 문자열 타입       | 문자열                                              |
|           | 불리언 타입       | true, false                                         |
|           | undefined 타입    | var 키워드로 선언된 변수에 암묵적으로 할당되는 값   |
|           | null 타입         | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값   |
|           | 심벌(symbol) 타입 | EX6에서 추가된 7번째 타입                           |
| 객체 타입 |                   | 객체, 함수, 배열 등                                 |

### 1. 숫자 타입

> 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.
> 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.

정수, 실수, 2진수, 8진수, 16진수 리터럴이 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다.
값을 참조하면 모두 10진수로 해석된다.

추가적으로 세 가지 특별한 값을 표현할 수 있다.

- **Infinity** : 양의 무한대
- **-Infinity** : 음의 무한대
- NaN: 산술 연산 불가 (not-a-number)

```js
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity
console.log(1 * "String"); // NaN
```

### 2. 문자열 타입

> 작은 따옴표(''), 큰 따옴표(""), 백틱(``, ES6)으로 텍스트를 감싼다.
> 일반적인 표기법은 작은 따옴표('')를 사용하는 것이다.
> 문자열을 감싸는 이유는 키워드나 식별자 같은 토큰, 공백 문자 등과 구분하기 위함이다.

### 3. 템플릿 리터럴

> ES5부터 백틱(``)을 사용한 문자열 표기법이 도입되었다.
> 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다.

#### 멀티라인 문자열

> 일반 문자열 내에서 허용되지 않는 줄바꿈(개행)을 허용한다.
> 일반 문자열에서는 이스케이프 시퀀스가 필요하다.

| 이스케이프 시퀀스 | 의미                                                           |
| ----------------- | -------------------------------------------------------------- |
| \0                | Null                                                           |
| \b                | 백스페이스                                                     |
| \f                | 폼 피드: 프린터로 출력할 경우 다음 페이지의 시작 지점으로 이동 |
| \n                | 개행(LF): 다음 행으로 이동                                     |
| \r                | 개행(CR): 커서를 처음으로 이동                                 |
| \t                | 탭(수평)                                                       |
| \v                | 탭(수직)                                                       |
| \uXXXX            | 유니코드                                                       |
| \'                | 작은 따옴표                                                    |
| \"                | 큰 따옴표                                                      |
| \\                | 백슬래시                                                       |

> LF(Line Feed)와 CR(Carriage Return)
> 라인 피드 : 커서를 정지한 상태에서 종이를 한 줄 올리는 것
> 캐리지 리턴 : 종이를 움직이지 않고 커서를 맨 앞 줄로 이동
> CRLF : 커서를 맨 앞으로 이동시키고 종이를 한 줄 올리는 방식의 개행
> 운영체제 별로 개행 방식이 다르다.
> 자바스크립트에서 라인 피드와 캐리지 리턴은 모두 개행을 의미하며 일반적으로 라인 피드(\n)을 사용해 개행한다.

```js
// 일반 문자열
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';
// 템플릿 문자열
var template = `<ul>
	<li><a href="#">Home</a></li>
</ul>`;
```

#### 표현식 삽입

> 문자열은 문자열 연산자 `+`를 사용해 연결할 수 있다. (피연산자 중 하나 이상이 문자열일 때)

```js
var firstName = "PPo";
var middleName = "F";
var lastName = "Man";

// 일반 문자열
var name = firstName + middleName + lastName;
// 템플릿 문자열
var name = `${firstName} ${middleName} ${lastName}`;
```

### 4. 불리언 타입

논리적 참, 거짓을 나타내는 `true`, `false`
조건문에서 자주 사용된다.

### 5. undefined 타입

`var`키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화된다.
선언 후 값이 할당된 적 없음을 알려줄 뿐이다. (undefined : 정의되지 않은)
개발자가 의도적으로 할당하지 말자.

### 6. null 타입

> 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재)하고 싶을 때는 `null`을 할당한다.

- 참조를 명시적으로 제거하는 것 : 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미

- 함수가 유효한 값을 반환할 수 없는 경우에 사용
  (ex. 조건에 부합하는 요소를 검색할 수 없을 때)

### 7. 심벌 타임

> ES6에서 추가된 타입. 다른 값과 중복되지 않는 유일무이한 값
> 이름이 충돌한 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌을 Symbol 함수를 호출해 생성한다.

- 외부에 노출되지 않는다.
- 다른 값과 절대 중복되지 않는 유일무이한 값이다.

### 8. 객체 타입

원시 타입과 객체 타입은 근본적으로 다르다.

> 자바스크립트는 객체 기반의 언어이다.
> 자바스크립트를 이루고 있는 거의 모든 것이 **객체**

### 9. 데이터 타입의 필요성

#### 데이터 타입에 의한 메모리 공간의 확보와 참조

값은 메모리에 저장하고 참조할 수 있어야 한다.

**값의 저장** <br>
자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보하고 저장한다.

**값의 참조** <br>
값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기(메모리 셀의 개수)를 알아야 한다.
자바스크립트 엔진은 변수가 숫자 타입의 값이라면 8바이트 단위로 메모리 공간에 저장된 값을 읽어 들인다.

> 심벌 테이블
> 컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.

#### 데이터 타입에 의한 값의 해석

메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다.

> 정리하자면 데이터 타입이 필요한 이유는 다음과 같다.

1. 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
2. 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
3. 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

### 10. 동적 타이핑

#### 동적 타입 언어와 정적 타입 언어

**정적 타입 언어**

- 사전에 변수에 할당할 수 있는 데이터 타입을 선언해야 한다. (명시적 타입 선언)
- 변수의 타입을 변경할 수 없고, 타입에 맞는 값만 할당할 수 있다.
- 컴파일 시점에 타입 체크를 수행한다.
- 타입의 일관성을 강제해 안정적인 코드 구현을 통해 런타임 에러를 줄인다.
  ex. C, C++, Java, Kotlin, Go, Haskell, Rust, Scala

**동적 타입 언어**

- 자바스크립트는 변수를 선언할 때 타입을 선언하지 않는다.
  다만 `var`, `let`, `const` 키워드를 사용해 변수를 선언하며 어떠한 데이터 값이라도 자유롭게 할당할 수 있다.
- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다.
- 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. (동적 타이핑)
  ex. JavaScript, Python, PHP, Ruby, Lisp, Perl

> 자바스크립트의 모든 값은 데이터 타입을 갖는다.
> Q. 변수는 데이터 타입을 가질까?
> A. 변수는 타입을 갖지 않는다. 값은 타입을 갖는다.

#### 동적 타입 언어와 변수

동적 타입 언어의 특징? 편리함

**편리함의 이면** <br>
동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다.
개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동적으로 변환될 수 있다.
=> 높은 유연성, 낮은 신뢰성

#### 변수를 사용할 때 주의할 사항

1. 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
2. 변수의 유효 범위(스코프)는 최대한 좁게 만들어 부작용을 억제한다.
3. 전역 변수는 최대한 사용하지 않는다.
4. 변수보다 상수를 사용해 값의 변경을 억제한다.
5. 변수 이름은 목적이나 의미를 알 수 있도록 네이밍 한다.

> "컴퓨터가 이해하는 코드는 어떤 바보도 쓸 수 있다. 하지만 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 쓴다." - 마틴 파울러

<br>
<br>

## 07장 연산자

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.

연산의 대상은 피연산자이며, 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.
피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.

### 산술 연산자

> 피연산자 대상 수학적 계산으로 새로운 숫자 값을 만든다.
> 산술이 불가능한 경우 NaN을 반환

#### 이항 산술 연산자

2개의 피연산자를 산술 연산한다.
모든 이항 산술 연산자는 새로운 값을 만든다.

| 이항 산술 연산자 | 의미   | 부수 효과 |
| ---------------- | ------ | --------- |
| +                | 덧셈   | X         |
| -                | 뺄셈   | X         |
| \*               | 곱셈   | X         |
| /                | 나눗셈 | X         |
| %                | 나머지 | X         |

#### 단항 산술 연산자

1개의 피연산자를 산술 연산하여 숫자 값을 만든다.

| 단항 산술 연산자 | 의미                                               | 부수 효과 |
| ---------------- | -------------------------------------------------- | --------- |
| ++               | 증가                                               | O         |
| --               | 감소                                               | O         |
| +                | 효과 없음                                          | X         |
| -                | 양수를 음수로, 음수를 양수로 반전한 값을 반환한다. | X         |

> 증감 연산자는 피연산자의 값을 변경하는 부수 효과가 있다. (암묵적 할당)

- prefix : 피연산자의 값을 증감한 뒤 다른 연산 수행 (++x)
- postfix : 다른 연산을 수행한 후 피연산자 증감 (x++)

```js
var x = 5,
  result;

// postfix
result = x++;
console.log(result, x); // 5 6

// prefix
result = ++x;
console.log(result, x); // 7 7
```

#### 문자열 연결 연산자

/+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
그 외에는 산술 연산자로 동작한다.

> 암묵적 타입 변환(타입 강제 변환)
> 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환될 수 있다.

### 할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.
변수 값이 변하는 부수 효과가 있다.

종류 : `=` `+=` `-=` `*=` `/=` `%=`

> 할당문은 표현식인 문이다. 할당문을 다른 변수에 할당할 수 있으므로 다음과 같은 연쇄 할당이 가능하다.
> var a = b = c = 0;

### 비교 연산자

좌항과 우항의 피연산자를 비교한 다음 결과를 불리언 값으로 반환한다.

#### 동등/일치 비교 연산자

좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.
동등 비교 연산자보다 일치 비교 연산자는 더 엄격한 비교를 한다.

| 비교 연산자 | 의미        | 설명                     | 부수 효과 |
| ----------- | ----------- | ------------------------ | --------- |
| ==          | 동등 비교   | x와 y의 값이 같음        | X         |
| ===         | 일치 비교   | x와 y의 값과 타입이 같음 | X         |
| !=          | 부동등 비교 | x와 y의 값이 다름        | X         |
| !==         | 불일치 비교 | x와 y의 값과 타입이 다름 | X         |

동등 비교는 암묵적 타입 변환으로 타입을 일치시킨 후 같은 값인지 비교한다. (예측 어려움)
일치 비교는 암묵적 타입 변환 없이 타입과 값이 같은 값인지 비교한다. (예측 쉬움)

##### NaN

일치 비교 연산자에서 주의할 것
NaN은 자신과 일치하지 않는 유일한 값이다.

#### 대소 관계 비교 연산자

피연산자의 크기를 비교하여 불리언 값을 반환한다.
종류 : `>` `<` `>=` `<=`

### 삼항 조건 연산자

조건식의 평가 결과에 따라 반환할 값을 결정한다. 부수 효과는 없다.

> 조건식? 조건식이 `true`일 때 반환할 값 : 조건식이 `false`일 때 반환할 값

삼항 조건 연산자 : 표현식인 문
if ... else 문 : 표현식이 아닌 문

### 논리 연산자

우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다.
`!` : 언제나 불리언 값을 반환
`||` `&&` : 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

> 드 모르간의 법칙을 활용하면 복잡한 표현식을 좀 더 가독성 좋은 표현식으로 변환할 수 있다.

```js
!(x || y) === (!x && !y);
!(x && y) === (!x || !y);
```

### 쉼표 연산자

왼쪽 연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

```js
var x, y, z;
(x = 1), (y = 2), (z = 3); // 3
```

### 그룹 연산자

소괄호()로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다.
그룹 연산자는 연산자 우선순위가 가장 높다.

### typeof 연산자

피연산자의 데이터 타입을 문자열로 반환한다.
반환되는 값 : `string`, `number`, `boolean`, `undefined`, `symbol`, `object`, `function`

- typeof null은 `object`를 반환하는 데 주의하자. 이때는 일치 연산자(===)를 사용할 것

```js
var foo = null;

typeof foo === null; // false
foo === null; // true
```

- 선언하지 않은 식별자를 typeof로 연산하면 `ReferenceError`가 아닌 `undefined`를 반환한다.

### 지수 연산자

ES7에서 도입. 좌항의 피연산자를 `밑`으로, 우항의 피연산자를 `지수`로 거듭 제곱하여 숫자 값을 반환한다.
이전에는 `Math.pow` 메서드를 사용했다.

- 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다.
- 이항 연산자 중에서 우선순위가 가장 높다.

### 그 외의 연산자

| 연산자     | 개요                                                        |
| ---------- | ----------------------------------------------------------- |
| ?.         | 옵셔널 체이닝 연산자                                        |
| ??         | null 연산자                                                 |
| delete     | 프로퍼티 삭제                                               |
| new        | 생성자 함수를 호출할 때 사용하여 인스턴스 생성              |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 |
| in         | 프로퍼티 존재 확인                                          |

### 연산자의 부수 효과

일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다.
ex. 할당 연산자, 증가/감소 연산자, delete 연산자

### 연산자 우선순위

| 우선 순위 | 연산자                                                                            |
| --------- | --------------------------------------------------------------------------------- |
| 1         | ()                                                                                |
| 2         | new(매개변수 존재), ., \[](프로퍼티접근), ()(함수 호출), ?.(옵셔널 체이닝 연산자) |
| 3         | new(매개변수 미존재)                                                              |
| 4         | x++, x--                                                                          |
| 5         | !x, +x, -x, ++x, --x, typeof, delete                                              |
| 6         | \*\*                                                                              |
| 7         | \*, /, %                                                                          |
| 8         | +, -                                                                              |
| 9         | <, <=, >, >=, in, instanceof                                                      |
| 10        | ==, !=, ===, !==                                                                  |
| 11        | ==, !=, ===, !==                                                                  |
| 12        | &&                                                                                |
| 13        | \|\|                                                                              |
| 14        | ? ... : ...                                                                       |
| 15        | 할당 연산자 ( =, +=, -=, ...)                                                     |
| 16        | ,                                                                                 |

### 연산자 결합 순서

연산자의 어느 쪽부터 평가를 수행할 것인지 나타내는 순서

| 결합 순서    | 연산자                                                                                       |
| ------------ | -------------------------------------------------------------------------------------------- | --- | ----------------------------------- |
| 좌항 -> 우항 | +, -, /, %, <, <=, >, >=, &&,                                                                |     | , ., [], (), ??, ?., in, instanceof |
| 우항 -> 좌항 | ++, --, 할당 연산자(=, +=, -=, ...), !x, +x, -x, ++x, --x, typeof, delete, ? ... : ..., \*\* |
