# 6. 데이터 타입
원시 타입 : number, string, boolean, undefined, null, Symbol, Bigint
객체 타입 : 객체, 함수, 배열 등

> #### [BigInt](https://ko.javascript.info/bigint)
> 숫자 끝에 n을 붙이거나 BigInt 함수에 문자열이나 숫자를 넣어 BigInt 타입을 지정

각각의 타입들은 확보해야할 메모리 공간의 크기도 다르고, 해석되는 방식도 다름

## 숫자 타입
숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따름. 
> #### [배정밀도 64비트 부동소수점 형식](https://vanillaani.tistory.com/6)
> 십진수인 소수를 이진수로 변환하고 소수점을 1.xxx 형식이 될 때까지 오른쪽 또는 왼쪽으로 옮긴 뒤, 소수점 오른쪽에 해당하는 수를 가수부분에 넣는데 이 수가 표현 자리수보다 넘어서게 되면 나머지 부분에서 반올림 처리를 하면서 근사값이 저장됨. -> 수의 계산이 정확하게 나오지 않는 이유 
> <details>
> <summary> 소수점 계산을 올바르게 하는 법 </summary>
> 1. toFixed 사용 <br/>
> 2. Math.round(x) 사용
> </details>

모든 수를 실수로 처리하며 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않음.

숫자타입은 추가적으로 다음의 값도 포함함
- `infinity` : 양의 무한대
- `-infinity` : 음의 무한대
- `NaN` : 산술 연산 불가 (대소문자 주의)

## 문자열 타입
텍스트 데이터를 나타내는 데 사용
문자열은 0개 이상의 16비트 유니코드 문자의 집합으로 대부분의 문자 표현 가능

자바스크립트의 문자열은 다른 언어와 달리 원시타입이며 변경 불가능한 값

## 템플릿 리터럴
편리한 문자열 처리기능을 제공
런타임에 일반 문자열로 변환되어 처리
백틱(\`)을 사용해 표현

### 멀티라인 문자열
일반 문자열 내에서는 개행이 허용되지 않음
공백을 표현하기 위해 백슬래시로 시작하는 이스케이프 시퀀스를 사용해야함.

> #### 라인 피드와 캐리지 리턴
> **라인 피드(LF, Line Feed)** : 커서를 정지한 상태에서 종이를 한 줄 올리는 것
> **캐리지 리턴(CR, Carriage Return)** : 종이를 움직이지 않고 커서를 맨 앞 줄로 이동
> 
> 초창기 컴퓨터는 CRLF(\r\n)를 모두 사용
> 현대 운영체제는 운영체제 별로 다른 개행 문자를 사용하기 때문에 서로 개행문자를 인식하지 못함. 일반적으로 LF를 사용해 개행

일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며 공백도 그대로 적용

### 표현식 삽입
`${}`을 이용해 표현식을 감싸 문자열 사이에 삽입 - 문자열로 타입이 강제로 변환됨

## undefined 타입
개발자가 의도적으로 할당하기 위한 갑싱 아니라 자바스트립트 엔진이 변수를 초기화 할 때 사용하는 값
-> 변수에 값이 없다는 것을 의도적으로 표현하고 싶을 때는`null` 사용

## null 타입
변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미
이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거 -> 가비지 콜렉션 수행

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null 반환

## 심벌 타입
변경 불가능한 원시 타입의 값
다른 값과 중복되지 않는 유일무이한 값으로 유일한 프로퍼티 키를 만들기 위해 사용

보통 원시값은 리터럴을 통해 생성하지만 심벌은 Symbol 함수를 통해 생성됨

## 데이터 타입의 필요성
- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할 지 결정하기 위해

## 동적 타이핑
### 동적 타입 언어와 정적 타입 언어
**정적 타입 언어**
- 변수를 선언할 때 변수에 할당할 수 있는 데이터 타입을 사전에 선언해야 함(명시적 타입 선언)
- 컴파일 시점에서 타입 체크 -> 런타임 에러를 줄임
- C, C++, Java 등등

**동적 타입 언어**
- 어떠한 데이터 타입의 값이라도 자유롭게 할당, 변경 가능
- 값을 할당하는 시점에서 변수의 타입이 동적으로 결정 (동적 타이핑)
- 선언이 아닌 할당에 의해 타입 결정 (타입 추론)
- Javascript, Python 등등

### 동적 타입 언어와 변수
복잡한 프로그램에서 변화하는 변수의 값을 추적하기 어려움
개발자의 의도와 상관 없이 타입이 자동으로 변환되기도 함
-> 유연성은 높지만 신뢰성은 떨어짐

**주의사항**
1. 변수는 꼭 필요한 경우에 한해 제한적으로 사용
2. 변수의 스코프를 최대한 좁게 만듦
3. 전역 변수의 사용 최소화
4. 변수보다 상수 사용
5. 변수 이름은 변수의 목적이나 의미 파악이 쉽게 네이밍


# 7. 연산자
**연산자** : 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리 등을 수행해 하나의 값을 만듦
**피연산자** : 연산의 대상으로 값으로 평가될 수 있는 표현식

## 산술 연산자
피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값 생성
불가능한 경우 NaN을 반환

### 이항 산술 연산자
2개의 피연산자를 산술 연산해 숫자 값을 계산
피연산자의 값을 변경하지 않고 새로운 값을 생성 (side effect X)

### 단항 산술 연산자
1개의 피연산자를 산술 연산해 숫자 값을 계산

증가/감소 연산자의 경우 다른 산술 연산자와 다르게 기존의 값을 변경

## 문자열 연결 연산자
`+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작
이런 경우 다른 피연산자가 문자열이 아니더라도 문자열로 타입 변경 (암묵적 타입 변환)

## 할당 연산자
우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당
할당문은 **값으로 평가되는 표현식인 문**으로서 할당된 값으로 평가
-> 값 ⭕️ 표현식 ⭕️

## 비교 연산자
좌항과 우항의 피연산자 비교 후 결과값을 불리언 값으로 변경

### 동등/일치 비교 연산자
동등 비교(`==`) : 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 일치시킨 후 같은 값인지 비교
일치 비교(`===`) : 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환

> NaN은 자신과 일치하지 않는 유일한 값으로 일치 비교 연산자에서 주의해야함. 숫자가 NaN인지 조사하기 위해선 Number.isNaN을 사용

> Object.is 메서드 사용 추천

## 삼항 조건 연산자
if...else문과의 가장 큰 차이점은 **값으로 사용 여부**
삼항 조건 연산자는 값으로 평가할 수 있는 표현식인 문

## 논리 연산자
논리 부정(!) 연산자는 언제나 불리언 값을 반환

## 쉼표 연산자
왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환

## 그룹 연산자 ()
연산자 우선 순위가 가장 높음

## typeof 연산자
피연산자의 데이터 타입을 문자열로 반환
null을 반환하는 함수는 없으며 함수는 function 반환
**typeof 가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지 않음**

**주의할 점**
- typeof null == "object"
- typeof 선언하지 않은 식별자 == undefined

## 지수 연산자
좌항의 피연산자를 밑으로 우항의 피연산자를 지수로 거듭 제곱
이전에는 `Math.pow()` 사용

## 연산자의 부수효과
다른 코드에 영향을 주는 연산자
- 할당 연산자 (`=`)
- 증가/감소 연산자 (`++`/`--`)
- `delete` 연산자

## 연산자 우선 순위
![](https://i.imgur.com/mHEBgIf.png)
![](https://i.imgur.com/X6pBV9R.png)

## 연산자 결합 순서
![](https://i.imgur.com/aUl9CY2.png)
![](https://i.imgur.com/Sho5KtM.png)









