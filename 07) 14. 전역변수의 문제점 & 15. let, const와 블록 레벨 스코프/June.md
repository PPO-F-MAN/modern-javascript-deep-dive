# 14. 전역 변수의 문제점

```javascript
function foo() {
  var x = "local";
  console.log(x); // local
  return x;
}

foo();
console.log(x); // ReferenceError: x is not defined
```

foo 함수를 호출하면 함수 몸체의 다른 문들이 순차적으로 실행되기 이전에 `x` 변수의 선언문이 자바스크립트 엔진에 의해 가장 먼저 실행됩니다.

그럼 `x` 변수가 `undefined`로 초기화되고, 변수 할당문이 실행되면 x 변수에 값이 할당됩니다. 그리고 함수가 종료하면 `x` 변수도 소멸됩니다.

지역변수는 생명 주기는 함수의 생명 주기와 일치합니다.

함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록됩니다. 스코프는 렉시컬 환경이라 부르는 물리적 실체가 있는데, 그래서 변수는 스코프가 소멸될 때까지 유효합니다.

근데 해당 메모리 공간을 계속 참조하고 있으면 함수가 종료되더라도, 스코프와 변수는 소멸하지 않고 생존하게 됩니다.

호이스팅은 스코프를 단위로 동작합니다.

## 14.1.2 전역 변수의 생명 주기

전역에서 생성한 변수들은 전역 객체의 생명주기와 동일해진다.
브라우저에서 전역 객체는 window다. 전역 객체 window는 브라우저를 닫기 전까지 유효한데, 그러면 `var`로 선언한 전역 변수는 브라우저를 닫을 때까지 유효하다.

# 14.2 전역 변수의 문제점

## 1. 암묵적 결합

> 모든 코드가 전역 변수를 참조하고, 재변경하겠다.

모든 코드가 참조하고 변경 가능 하면?

- 가독성이 떨어질 수 있다.
- 의도치 않은 변경이 일어날 수 있다.

## 2. 긴 생명주기

> 전역 변수는 생명 주기가 길다.

생명 주기가 길면?

- 메모리 소비 기간이 길어진다.
- 의도치 않은 변경이 일어날 수 있다.
- 상태를 변경할 수 있는 기회와 시간이 길어진다.

## 3. 스코프 체인 상에서 종점에 존재

> 변수를 검색할 때 가장 마지막에 검색된다.

가장 마지막에 검색되면?

- 검색의 속도가 가장 느리다. : 가장 마지막에 검색되니까 (속도의 차이는 크지 않지만 차이는 분명히 있다.)

## 4. 네임스페이스 오염

> 자바스크립트는 파일이 분리되어 있어도 전역 스코프를 공유한다.

다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.

# 14.3 전역 변수의 사용을 억제하는 방법

> 전역 변수는 남용하면 안된다. 변수의 스코프는 좁을수록 좋다.

1. 즉시실행함수 (IIFE)

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

```javascript
(() => {
  // ...
}());
```

2. 네임스페이스 객체 사용

네임스페이스 객체 자체가 또 전역 변수에 할당되니까 그닥 유용한 방법은 아닌 것 같다고 책에서 그랬다.

```javascript
var MYAPP = {}; // 전역 네임스페이스 객체
```

3. 모듈 패턴

> 모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다.

```javascript
var Counter = (function () {
  // private member
  var num = 0;

  // public member
  return {
    increase: () => {
      return ++num;
    },
    decrease: () => {
      return --num;
    },
  };
})();
```

외부에 노출하고 싶은 건 return 객체에 포함하지 않으면 되고, 외부에 노출하고 싶다면 return에 노출시키면 된다. 이렇게 캡슐화를 실현시킬 수 있다.

4. ES6 모듈

> ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없다. ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.

```html
<script type="module" src="app.mjs"></script>
```

ES6 문법은 구형 브라우저에서는 동작하지 않으므로, 바벨을 통해서 문법을 전환하거나, 웹팩 같은 모듈 번들러를 통해서 합치는 것이 일반적이다.

# 15. let, const 키워드와 블록 레벨 스코프

ES5까지는 `var`로만 변수를 선언할 수 있었다. `var`의 특징은 다음과 같다.

## 15.1.1 변수 중복 선언 허용

```javascript
var x = 1;

// doing something

// 중복 선언을 허용한다.
var x = 100;
```

`var` 키워드 중복 선언을 해도 에러가 나지 않기 때문에 만약 동일한 이름의 변수가 선언되어 있는 것을 모르고 변수를 중복 선언하면서 덮어 씌울 수 있기 때문에 의도치 않은 동작이 일어날 수 있다.

## 15.1.2 함수 레벨 스코프

`var` 키워드로 선언한 변수는 함수 레벨 스코프를 가진다.
그래서 블록 내에서 선언해도 모두 전역 변수가 된다.

```javascript
var x = 1;

// x는 전역 변수다.
// 이미 선언된 값을 덮어 씌운다.
if (true) {
  var x = 10;
}

console.log(x); // 10
```

## 15.1.3 변수 호이스팅

`var` 키워드는 선언 이전에 참조가 가능하다.

`var`는 undefined로 맨 처음 선언이 되고, 실제 값은 할당문에서 일어나기 때문에 그 전에 참조를 하면 undefined가 뜬다.

에러를 발생하지 않지만 가독성이 떨어지고, 예측이 불가능하다.

# 15.2 let 키워드

## 15.2.1 변수 중복 선언 금지

`var` 키워드와 다르게 중복 선언하게 된다면 에러를 뱉는다.

## 15.2.2 블록 레벨 스코프

`let` 키워드는 블록 레벨 스코프를 따른다. 함수, if문, for문, while문, try-catch문 등이 블록이고, 이 안의 생명주기와 같게 동작한다.

```javascript
let i = 10; // 전역 변수

function foo() {
  let i = 100; // 함수 레벨 스코프

  // 블록 레벨 스코프
  for (let i = 0; i < 3; i++) {
    console.log(i); // 0, 1, 2
  }

  console.log(i); // 100
}

foo();
console.log(i); // 10
```

## 15.2.3 변수 호이스팅

`let` 키워드 변수는 **선언 단계**와 **초기화 단계**가 분리되어 진행된다. 자바스크립트 엔진은 선언을 먼저 실행하고, 변수 선언문에 도달했을 때 초기화가 진행된다.

만약 초기화 이전에 변수에 접근하려고 하면 자바스크립트는 참조 에러를 뱉는다.

`var`는 선언과 동시에 `undefined`를 할당해서 선언과 초기화 단계 사이에서 접근을 할 수 있었는데, `let` 키워드는 선언 이후에 초기화가 일어나지 않았을 때 접근을 하려고 하면 참조 에러를 일으킨다. 그래서 변수를 참조할 수 없는 이 구간을 일시적 사각지대(TDZ: Temporal Dead Zone)라고 부른다.

`let`과 `const`가 호이스팅이 동작하지 않는 것 처럼 동작해서 호이스팅이 일어나지 않는다고 생각할 수 있지만, 실제로는 일어난다.

```javascript
let foo = 1; // 전역 변수

{
  // 참조 에러가 이유가 호이스팅이 일어났다는 이유다.
  // 원래는 호이스팅이 일어나지 않았으면 1을 띄워야 하는데
  // 호이스팅이 일어나서, 할당문을 아직 만나지 못했기 때문에 참조에러를 띄우는 것!
  console.log(foo); // ReferenceError
  let foo = 2; // 지역 변수
}
```

# 15.3 const 키워드

`let`과 `const`는 거의 비슷하게 동작한다. 그래서 `let`과 다른 점을 살펴보자

## 15.3.1 선언과 초기화

`let` 키워드는 선언과 동시에 초기화를 해주지 않아도 에러가 나지 않는다.
하지만 `const` 키워드는 선언과 동시에 초기화를 해주지 않으면 에러가 난다.

```javascript
const a; // SyntaxError: Missing initializer in const declaration
```

## 15.3.2 재할당 금지

```javascript
const foo = 1;
foo = 2; // TypeError: Assignment to constant variable.
```

## 15.3.4 const와 객체

> const에 원시 값을 할당한 경우에는 변경이 불가능하지만, 객체를 할당한 경우에는 변경할 수 있다.

```javascript
const me = { name: "hyeonsu" };

me.name = "sally";

console.log(me); // { name: 'sally' }
```

**재할당 금지**와 **불변성**은 다른 말이다. 객체는 참조값을 저장하고 있기 때문에 참조 값의 저장, 삭제, 추가는 가능하다.
