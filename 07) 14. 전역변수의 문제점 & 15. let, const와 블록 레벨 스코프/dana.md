# 14. 전역 변수의 문제점

## 14.1 변수의 생명 주기
### 14.1.1 지역 변수의 생명 주기
변수는 선언에 의해 생성되고, 할당을 통해 값을 값을 갖고 소멸하는 생명주기를 갖고 있음.
변수는 자신이 선언된 위치에서 생성되고 소멸
-> **`전역변수`의 생명주기** == 애플리케이션의 생명 주기
-> **`지역변수`의 생명주기** == 함수의 호출과 종료 (함수의 생명 주기)

전역 변수에서는 변수 선언이 런타임 이전에 실행되지만, 함수 내부에서 선언한 변수는 함수가 호출된 직후, 함수 몸체의 코드가 한 줄씩 순차적으로 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행.

**변수의 생명 주기** 
- 메모리 공간이 확보된 시점 ~ 메모리 공간이 해제되어 가용 메모리 풀에 반환
- 자신이 등록된 스코프가 소멸될 때까지 유효
- 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아있게 된다.

```javascript
var x = 'global';

function foo(){
    console.log(x); // 2. 지역변수 x 호출 -> x: undefined
    var x = 'local'; // 1. x 식별자 선언 / 3. x에 값 할당
}

foo();
console.log(x);
```

**호이스팅**
- 스코프를 단위로 동작
- 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

### 14.1.2 전역 변수의 생명 주기
전역 코드는 함수와 달리 명시적인 호출 없이 코드가 로드되자마자 곧바로 해석되고 실행됨. 전역 변수는 전역 객체의 프로퍼티가 되는데, 이는 곧 전역 변수의 생명 주기가 전역 객체의 생명주기와 일치한다는 것을 의미

> 전역 객체
> 코드가 실행되기 전에 자바스크립트 엔진에 의해 가장 먼저 생성되는 특수한 객체
> 환경에 따라 객체를 가리키는 다양한 식별자가 존재했으나, ES11에서 globalThis로 통일됨

## 14.2 전역 변수의 문제점
### 암묵적 결합
전역 변수를 선언하는 의도 : 코드를 어디서든 참조하고 할당할 수 있는 변수로 사용하겠다 (= 암묵적 결합)

### 긴 생명 주기
전역 변수는 생명 주기가 길다 == 리소스를 오랜 기간 소비함.
또한 var는 변수의 중복 선언을 허용하므로 변수 이름의 중복 가능성이 높아짐.

### 스코프 체인 상에서 종점에 존재
종점에 존재 == 가장 마지막에 검색되어 검색 속도가 가장 느림

### 네임스페이스 오염
파일이 분리되어있다 해도 하나의 전역 스코프를 공유
-> 다른 파일에서 동일한 이름으로 전역변수나 전역함수가 존재하는 경우, 예상치 못한 에러 발생 가능성 존재

## 14.3 전역 변수의 사용을 억제하는 방법
전역 변수를 반드시 사용해야 하는 이유가 없다면 지역 변수를 사용해야한다. 
변수의 스코프는 작으면 작을 수록 좋음.

### 14.3.1 즉시 실행 함수
모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨. 
(라이브러리 등에 주로 사용)

### 14.3.2 네임스페이스 객체
전역에 네임스페이스 역할을 하는 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가

```javascript=
var MYAPP = {};

MYAPP.name = 'dana';

console.log(MYAPP.name);
```

그 안에서 계층적으로 분리할 수 있다는 장점이 있으나, 결국 네임스페이스도 전역 변수의 프로퍼티로 선언된다는 단점이 있음.

### 14.3.3 모듈 패턴
클래스를 모방해서 관련있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈 생성
클로저를 기반으로 동작하며 전역 변수의 억제, 캡슐화 구현 가능

**캡슐화**
`객체의 상태를 나타내는 프로퍼티`와 `프로퍼티를 참조하고 조작할 수 있는 동작인 메서드`를 하나로 묶는 것
정보은닉을 위해 사용되기도 함.

자바스크립트에서는 public, private, protected등의 접근 제한자를 제공하지 않기 때문에, 

<Details>
    <Summary>
        한번도 사용해보진 않았지만 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields">private</a> 접근 제한자가 생겼음
    </Summary>

   <p> ECMAScript 2022, the 13th edition, the #x in obj syntax, to test for presence of private fields on objects; </p>
    
</Details>


```javascript=
var Counter = (function() {
    // private 변수
    var num = 0;
    
    // 외부에 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환
    return {
        increase(){
            return ++num;
        }
    }
}());

console.log(Counter.num) // undefined
console.log(Counter.increase()) // 1
```

Counter는 즉시실행함수가 반환한 객체값을 갖게됨. 

### 14.3.4 ES6 모듈
ES6 모듈을 사용하면 전역 변수 사용 불가능
-> 파일 자체의 독자적인 모듈 프로세스를 제공하기 때문
```htmlmixed=
<script type="module" src='lib.mjs'></script>
```

IE를 포함한 구형 브라우저에서는 동작하지 않음.
-> ES6의 모듈 기능을 사용하지 못하는 경우에는 Webpack등의 모듈 번들러를 사용

# 15. let, const 키워드와 블록 레벨 스코프
## 15.1 var 키워드로 선언한 변수의 문제점
### 15.1.1 변수 중복 선언 허용

```javascript=
var x = 1;
var y = 1;

var x = 100;
var y;

console.log(x); // 100
console.log(y); // 1
```
- `var x = 100;` : 초기화문에 있는 변수 선언문은 자바스크립트 엔진에 의해 var키워드가 없는 것처럼 동작
- `var y;` : 초기화문이 없는 변수 선언문은 무시됨.

### 15.1.2 함수 레벨 스코프
var키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정
if문이나 for문 등에서 사용되는 var변수는 전역으로 선언되니 주의해서 사용하기

### 15.1.3 변수 호이스팅
변수 호이스팅에 의해 스코프의 선두로 끌어올려진 것처럼 동작
할당문 이전에 변수를 참조하면 undefined를 반환

## 15.2 let 키워드
### 15.2.1 변수 중복 선언 금지
변수 중복 선언이 SyntaxError 발생

### 15.2.2 블록 레벨 스코프
let키워드로 선언한 변수는 모든 코드 블록을 지역스코프로 인정하는 블록레벨 스코프를 따름

### 15.2.3 변수 호이스팅
let으로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작
변수 선언문 이전 참조시, ReferenceError 발생

var로 선언한 변수는 선언 단계와 초기화 단계가 동시에 진행되지만,
let으로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행.
스코프 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적 사각지대**하고 함.

변수 호이스팅이 발생하지 않는 것처럼 보이지만, 변수 호이스팅은 존재

```javascript=
let foo = 1;

{
    console.log(foo); // Reference Error
    let foo = 2;
}
```

> 자바스크립트는 ES6에서 도입된 let , const 를 포함해서 모든 선언( var , let , const , function ,
function* , class 등)을 호이스팅한다. 단, ES6에서 도입된 let , const , class 를 사용한 선언문은 호이스 팅이 발생하지 않는 것처럼 동작한다. (????)


### 15.2.4 전역 객체와 let
전역 객체의 프로퍼티가 아니므로 window.x로 접근할 수 없음.
보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재

## 15.3 const 키워드
상수를 선언하기 위해 사용
키워드 특징은 let키워드와 비슷하게 동작

### 15.3.1 선언과 초기화
const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 함.
그렇지 않으면 SyntaxError 발생

### 15.3.2 재할당 금지
const 키워드로 선언한 변수는 재할당 금지~

### 15.3.3 상수
원시 값을 할당한 경우 변수값을 변경할 수 없음.
- 상태 유지
- 가독성
- 유지보수의 편의
위 특징들을 위해 상수를 적극적으로 활용

원시값을 할당한 경우, 원시값은 변경할 수 없는 값이고 const키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법이 없음
대부분 대문자로 선언해 상수임을 명확히 나타내고, 여러 단어로 이뤄진 경우 언더스코어로 구분해 스네이크 케이스로 표현

### 15.3.4 const 키워드와 객체
const로 선언된 변수에 객체를 할당한 경우엔 값을 변경할 수 있음.
동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능

## 15.4 var vs let vs const 
- ES6 사용시 var 사용 X
- 재할당이 필요한 경우에만 let 사용. 이 때 변수의 스코프는 최대한 좁게
- 변경이 발생하지 않고 읽기 전용으로 사용하는 원시값과 객체에는 const 사용

-> 일단 const를 사용하고 재할당이 필요하면 그 때 let으로 변경
