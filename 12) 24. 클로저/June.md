# 24. 클로저

> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

요기서 핵심은 **함수가 선언된 렉시컬 환경**이다.

# 24.1 렉시컬 스코프

> 우리가 전에서 this는 호출될 때 결정된다면, 스코프는 선언, 즉 정의를 어디서 했느냐에 따라 결정된다.

사전적 의미는 **정적** 스코프이다. 그래서 함수를 어디 정의했는지에 따라 상위 스코프를 결정한다.
함수의 상위 스코프는 함수를 정의한 위치에 의해 정적으로 결정되고 변경되지 않는다.

렉시컬 스코프는 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 렉시컬 스코프다.

# 24.2 함수 객체의 내부 슬롯 `[[Environment]]`

전역에 정의된 함수 선언문은 전역 코드가 평가되는 시점에 평가되어 함수 객체를 생성한다. 이 때 생성된 함수 객체의 내부 슬롯인 `[[Environment]]` 에는 함수 정의가 평가되는 시점, 즉 전역 코드 평가 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경인 외부 함수 렉시컬 환경의 참조가 저장된다.

함수 객체의 내부 슬롯 `[[Environment]]`에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프다.

함수 호출 -> 함수 내부로 코드 제어권 이동 -> 함수 코드 평가 -> 함수 실행 컨텍스트 생성 -> 함수 렉시컬 환경 생성 (함수 환경 레코드 생성, this 바인딩, 외부 렉시컬 환경에 대한 참조 결정)

# 24.3 클로저와 렉시컬 환경

- 자바스크립트의 모든 함수는 자신의 상위 스코프를 기억한다. 모든 함수가 기억하는 상위 스코프는 함수를 어디서 호출하든 상관없이 유지된다. 따라서 함수를 어디든 호출하든 상관없이 함수는 언제나 자신이 기억하는 상위 스코프의 식별자를 참조할 수 있으며 식별자에 바인딩된 값을 변경할 수도 있다.
- 사실 자바스크립트의 모든 함수는 상위 스코프를 기억하니까, 전부 클로저라고 볼 수 있지만 상위 스코프의 어떤 식별자도 참조하지 않는 함수는 클로저가 아니다.
- 참조하지도 않는 식별자를 기억하는 것은 메모리 낭비이기 때문에 소멸시켜버린다.
- 자신의 외부 식별자를 참조해서 클로저처럼 동작하고 있지만, 내부 함수가 반환이 되지 않는 경우도 있다. 그 경우에는 외부 함수보다 내부 함수가 더 생명주기가 짧으므로 클로저의 본질에 부합하지 않는다. 이 경우도 보통은 클로저라고 하지 않는다.

요기서 우리는 클로저 이름의 의미를 알 수 있다. **함수가 자유 변수에 대해 닫혀있다.**라는 의미이다. **자유 변수에 묶여있는 함수**라고 풀어 쓸 수 있다.

# 24.4 클로저의 활용

> 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.
