# 26. ES6 함수의 추가 기능

# 26.1 함수의 구분

> ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. ES6에서는 목적에 따라 함수를 세 가지 종류로 명확히 구분했다.

- 일반함수
- 메서드
- 화살표 함수

## 메서드

> ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다.

```javascript
const obj = {
	x: 1,
	foo() { return this.x };
	bar: function() {
		return this.x;
	}
}
```

위에서 bar는 그냥 일반 함수고 foo는 메서드다.

ES6 사양에서 정의한 메서드는 인스턴스를 생성할수 없는 Non-constructor다. 따라서 ES6 메서드는 생성자 함수로서 호출할 수 없다.

본연의 기능 super를 추가하고, 의미적으로 맞지 않은 constructor 기능은 제거했기 때문에
**메서드를 정의할 때 프로퍼티 값으로 익명 함수 표현식을 할당하는 ES6 이전의 방식은 사용하지 않는 것이 좋다.**

## 화살표 함수

> 화살표 함수는 표현만 간략한 것이 아니라 내부 동작도 기존의 함수보다 간략하다.

화살표 함수와 일반 함수의 차이는 아래와 같다.

1. 화살표 함수는 인스턴스를 생성할 수 없다. non-constructor이다, new 연산자를 통해서 인스턴스를 생성하지 못한다는 것.
2. 화살표 함수는 인스턴스를 생성할 수 없으니 Prototype 프로퍼티가 없고, 프로토타입도 생성하지 않는다.
3. 중복된 매개변수 이름을 선언할 수 없다. (일반함수는 가능, 단 strict mode에선 안됨)
4. 화살표 함수는 함수 자체의 this, arguments, super, new target 바인딩을 갖지 않는다.
   - 만약 화살표 함수에서 위의 키워드들을 참조하려고 하면 상위 스코프 체인에서 찾는다.

## 화삻표 함수와 일반 함수의 가장 큰 차이는 This다.

> 다시 기억하자. this는 호출할 때 결정한다.

- 화살표 함수는 상위 스코프의 this를 가리킨다.
- 화살표 함수는 함수 자체의 this 바인딩을 가지지 않는다. 그래서 화살표 함수 내부에서 This를 참조하면 상위 스코프의 this를 그대로 참조한다. 이것을 Lexical this라고 한다.
- 화살표 함수에서 this를 참조하면 상위 스코프중에서 화살표 함수가 아닌 함수의 this를 참조하게 되어있다.
- 화살표 함수는 함수 자체의 this 바인딩이 없어서 bind, call, apply 메서드가 먹히지 않는다.
- 메서드를 화살표 함수로 정의하는 것은 피하자. this가 어디로 튈지 모른다.

```javascript
// 메서드의 좋은 예
const person = {
  name: "Lee",
  sayHi() {
    console.log("Hi");
  },
};
```

## super

> 화살표 함수는 함수 자체의 super를 갖지 않는다. 따라서 this와 마찬가지로 상위 스코프의 super를 참조한다.

## arguments

> 화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않는다. 또 상위 스코프의 arguments를 참조한다.

만약 화살표 함수에서 arguments를 받아와서 가변 인수에 대한 대처를 하고 싶으면 Rest 파라미터를 사용해야한다.

# Rest 파라미터

> 나머지 매개변수 라는 의미로 사용할 수 있고 ... 키워드를 통해서 사용할 수 있다.

- Rest 파라미터는 함수 파라미터 마지막에 사용할 수 있다. (첫번째나 두번째,,, 이렇게 사용하면 에러남)
- 화살표 함수에서 가변 인자 함수를 구현하고자 한다면 반드시 Rest 파리미터를 사용해야 한다.

# 매개 변수의 기본 값 도입

```javascript
function sum(x = 0, y = 0) {
  // 인수 체크 및 초기화를 간소화 할 수 있다.
  console.log(x, y);
}

sum(undefined, null); //  0 null
```

- undefined 를 전달한 경우에만 유효하다
- Rest 파라미터는 기본 값을 지정할 수 없다.
