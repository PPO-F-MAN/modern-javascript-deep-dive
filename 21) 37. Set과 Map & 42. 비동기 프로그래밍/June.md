# Set

> Set 객체는 중복되지 않는 유일한 값들의 집합이다. Set 객체는 배열과 유사하지만 다음과 같은 차이가 있다.

## Set 객체의 생성

```js
const set = new Set();
const set = new Set([1, 2, 3, 4]); // 이터러블을 받아 생성 가능
const set = new Set('Hello'); // 이터러블을 받아 생성 가능
```

## 요소 개수 확인

```js
const { size } = new Set([1, 2, 3, 3]);
console.log(size) // 3
```

## 요소 추가

```js
const set = new Set();
set.add(1)
```

- add 메서드는 연속적으로 호출 가능
- 중복된 요소는 추가되지 않는다 (에러는 나지 않음)

## 요소 존재 여부 확인

```js
const set = new Set([1,2,3]);

set.has(2); // true
set.has(4); // false
```

## 요소 삭제

```js
const set = new Set([1, 2, 3]);

set.delete(2);
console.log(set) // Set(2) [1, 3]
```

- 존재하지 않는 요소를 삭제하려하면 에러는 뜨지 않는다. (아무일도 일어나지 않음)
- 삭제 여부의 불리언 값을 반환한다.
- 연속적으로 호출할 수 없다.

## 요소 일괄 삭제

```js
set.clear();
```

## 요소 순회

- forEach 메서드를 사용한다.

```js
const set = new Set([1, 2, 3]);

set.forEach((v, v2, set) => console.log(v, v2, set));
```

- v와 v2는 똑같은 요소고, 배열의 forEach와 인터페이스를 같게 하기 위함이고 다른 이유는 없다.
- Set 객체는 이터러블이라서 for ... of 로 순회가능하고 스프레드 문법과 배열 디스트럭처링의 대상이될 수도 있다.

# Map

> Map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다. Map 객체는 객체와 유사하지만 다음과 같은 차이가 있다.

- 객체와 유사하지만 Map은 이터러블하고, 객체는 이터러블하지 않다.
- 객체는 length로 사이즈를 확인하고 Map은 size 메서드로 확인한다.

## Map 객체의 생성

> Map 생성자 함수는 이터러블 인수로 전달받아 Map 객체를 생성한다. 이때 인수로 전달되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.

```js
const map = new Map();

const map1 = new Map([['key1', 'value1'], ['key2', 'value2']])
```

## 요소 개수 확인

- size 메서드로 확인 가능

## 요소 추가

- set 메서드 사용

```js
map.set('key', 'value');
```

- set 메서드는 연속적으로 호출 가능하다.

## 요소 취득

- get 메서드 사용

```js
map.get('key');
```

## 요소 존재 여부 확인

- has 메서드 사용

```js
map.has('key');
```

## 요소 삭제

- delete 메서드 사용

```js
map.delete('key');
```

## 요소 일괄 삭제

- clear 메서드 샤용

## 요소 순회

- forEach 메서드 사용
- 첫 번째는 순회 중인 요소값, 두 번째 인수는 요소키, 세 번째 인수는 Map 객체 자체

```js
map.forEach((value, key, map) => console.log(value, key, map));
```

- Map 객체도 똑같이 이터러블이라서 for...of 사용가능, 스프레드 문법, 배열 디스트럭처링 할당 대상도 된다.

## 이터러블 메서드

- Map.keys()
- Map.values()
- Map.entries()

# 비동기 프로그래밍

## 이벤트 루프

> 이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나다.

구글의 V8 자바스크립트 엔진을 비롯해서 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분할 수 있다.

- 콜스택 (실행 컨텍스트가 추가되고 제거되는 스택 자료구조)
- 힙 (객체가 저장되는 메모리 공간)

비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당한다.

예를 들어서 `setTimeout`의 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당하지만 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저 또는 Node.js가 담당한다. 이를 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다.

- 태스크 큐 (비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역)
- 이벤트 루프 (콜 스택에 실행 중인 실행 컨텍스트가 없다면 태스크 큐에 순차적으로 콜 스택으로 옮긴다.)

자바스크립트는 싱글 스레드 방식으로 동작하는데, 이때 싱글 스레드 방식으로 동작하는 것은 브라우저가 아니라 브라우저에 내장된 자바스크립트 엔진이라는 것에 주의하자.

만약 모든 자바스크립트 코드가 자바스크립트 엔진에서 싱글 스레드 방식으로 동작한다면 자바스크립트는 비동기로 동작할 수 없다.

- 자바스크립트 엔진 = 싱글 스레드
- 브라우저 환경 = 멀티 스레드


