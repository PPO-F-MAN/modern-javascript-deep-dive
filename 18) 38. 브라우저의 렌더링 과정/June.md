# 브라우저 동작 원리

1. 브라우저는 HTML, CSS, JavaScript, Image, Font... 등 렌더링에 필요한 리소스를 웹 서버에 요청하고 서버로부터 응답을 받습니다.

2. 받아온 HTML, CSS를 파싱해서 DOM, CSSOM을 생성하고 이들을 결합해서 Render Tree를 생성합니다.
 
3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하고 실행합니다. 이 때 자바스크립트는 DOM API를 통해서 DOM이나 CSSOM을 변경할 수 있습니다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합됩니다.

4. 렌더 트리를 기반으로 HTML 요소의 위치와 크기를 계산하는 레이아웃과정을 거친다음 실제로 유저들에게 보여주기 위해서 그림을 그리는 페인트 과정을 수행합니다.

---

# 조금 더 깊게

### 1. 네트워킹 과정

브라우저에 주소창에 요청을 보낼 주소를 입력하고 엔터를 입력하면 URL의 호스트 네임이 DNS를 통해서 IP주소로 변경되고 IP 주소를 갖는 서버를 찾아가서 요청을 전송합니다.

- 이 때 요청하지 않은 img, CSS, JavaScript는 어떻게 가져오는 이유는 HTML을 파싱하는 도중에 외부 리소스를 로드하는 태그들(link, script, img)을 만나면 HTML 파싱을 멈추고 해당 리소스 파일을 서버로 요청합니다.

- HTTP 1.1과 HTTP 2.0의 차이점은 1.1은 하나의 커넥션당 하나의 요청, 응답만 가능하지만 2.0은 하나의 커넥션에 다중 요청, 다중 응답이 가능합니다. 그래서 여러 리소스의 동시 전송이 가능하니까 페이지 로드 속도가 50% 빠르다고 합니다.

### 2. HTML을 파싱하여 DOM을 생성

받아온 HTML은 단순한 문자열로 이루어진 텍스트입니다. 그걸 브라우저가 이해할 수 있는 자료구조 (객체)로 바꾸어서 메모리에 저장해야 합니다. 이것을 파싱 과정이라고 하는데 파싱의 간략한 과정은 아래와 같습니다.

- HTML 문자열 자체를 메모리에 저장하고, 저장된 바이트(2진수)를 인터넷을 경유해서 응답합니다.
- 바이트 형태의 HTML 문서는 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환합니다.
- 문법적 의미를 갖는 코드의 최소 단위인 토큰으로 분해합니다.
- 토큰들을 객체화해서 노드를 생성합니다.
- HTML 노드 간의 부자 관계를 반영해서 모든 정보를 저장한 DOM을 생성합니다. 해당 자료구조는 트리 자료구조입니다.

### 3. CSS 파싱, CSSOM 생성

HTML을 처음부터 한 줄씩 파싱하다가 `<link>` 태그나 `<style>` 태그를 만나면 DOM 생성을 일시 중단하고 link 태그의 href 어트리뷰트에 지정된 CSS 파일을 서버에 요청해서 로드한 CSS 파일이나 style 태그 내의 CSS를 HTML과 동일한 파싱 과정 (바이트 -> 문자 -> 토큰 -> 노드 -> CSSOM)을 거치면서 해석하면서 CSSOM을 만듭니다. CSS를 만드는 과정이 끝나면 HTML 파싱이 멈춘 순간부터 다시 시작합니다.

### 4. 렌더 트리 생성

DOM, CSSOM을 결합해서 렌더트리를 생성합니다. 렌더 트리는 말 그대로 렌더링을 위한 트리 구조의 자료구조입니다. 렌더 트리에는 CSS에 의해 표시되지 않는 것은 포함하지 않습니다. 브라우저에 렌더링 되는 부분만 가지고 있습니다.

브라우저 렌더링 과정은 반복해서 실행될 수 있습니다.
- 자바스크립트에 의한 노드 추가 또는 삭제
- 브라우저 창의 리사이징, 뷰포트 크기 변경
- HTML 요소의 레이아웃에 변경을 일으키는 스타일 변경 (width, height, margin, padding, border, dispalay, position, top, right, bottom, left... 등등)

레이아웃 계산과 페인팅을 다시 실행하는 리렌더링은 비용이 많이 드는, 즉 성능에 좋지 않은 영향을 줍니다. 그래서 주의가 필요합니다.

### 5. 자바스크립트 파싱과 실행

HTML을 파싱하다가 `<script>` 태그를 만나면 DOM 생성을 중단하고 script 태그의 src 어트리뷰트에 위치해있는 자바스클비트 파일을 서버에 요청해서 자바스킓트 코드를 파싱하기 시작합니다. 그리고 종료되면 또 HTML 파싱이 종료된 곳부터 다시 HTML 파싱을 시작합니다.

자바스크립트 파싱은 렌더링 엔진이 아니라 자바스크립트 엔진이 처리합니다. 크롬의 V8, 파이어폭스의 SpiderMonkey, 사파리의 JavaScriptCore 등등의 엔진들이 있습니다.

### 6. 리플로우와 리페인트

DOM을 변경, CSSOM을 변경하는 코드를 작동하면 브라우저 렌더링 과정중에서 DOM 트리를 생성하거나 CSSOM을 생성하는 과정이 한번 더 일어납니다. 그럼 렌더 트리도 다시 생성하게 되는데, 이 과정은 리플로우라고 합니다.

리플로우는 레이아웃 계산을 다시 하는 것을 말하며, 노드 추가/삭제, 요소의 크기/위치 변경 등등 레이아웃에 영향을 주는 변경이 발생하면 리플로우가 일어나고

레이아웃에 영향을 주지 않으면 리플로우는 일어나지 않고 리페인트만 일어납니다.

그래서 성능향상을 위해서는 레이아웃을 변경시켜서 DOM, 렌더트리를 다시 만드는 고비용의 절차들을 밟지 않는 리페인트를 하도록 유도해야 합니다.

### 7. HTML 파싱 중단

HTML 파싱은 동기적으로, 위에서 아래로 순차적으로 일어나기 때문에 태그의 위치가 중요합니다.

DOM이나 CSSOM을 변경하는 DOM API를 사용할 경우에는 DOM과 CSSOM이 이미 생성이 되어 있어야 합니다. 그래서 script 태그는 웬만하면 body 제일 하단에 위치시키는 것이 좋습니다.

- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수 있고
- 자바스크립트 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간이 단축될 수 있습니다.

script 태그의 `async/defer` 어트리뷰트를 사용하면 DOM 생성이 중단되는 문제를 근본적으로 해결할 수 있습니다.

`async` 어트리뷰트는 비동기적으로 자바스크립트 파일을 로드합니다. 순서가 보장이 되지 않기 때문에 순서가 중요한 스크립트 태그에는 사용하면 안됩니다.

`defer` 어트리뷰트도 `async`와 마찬가지로 비동기적으로 동시에 파일을 로드하지만, 실행은 HTML 파싱이 완료되고 난 다음에 JavaScript를 파싱합니다.
