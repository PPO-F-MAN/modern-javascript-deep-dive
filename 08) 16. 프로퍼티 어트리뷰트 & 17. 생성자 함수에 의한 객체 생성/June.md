# 16. 프로퍼티 어트리뷰트

## 16.1 내부 슬롯과 내부 메서드

모든 객체는 `[[Prototype]]` 이라는 내부 슬롯을 갖는다. 내부 슬롯은 자바스크립트 엔진 내부 로직이므로 원래는 접근이 불가능하지만, `[[Prototype]]` 내부 슬롯은 예외적으로 `__proto__`를 통해서 접근이 가능하다. (던더 프로토)

## 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

> 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

## 16.3 데이터 프로퍼티와 접근자 프로퍼티

- 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티.
- 접근자 프로퍼티: 자체적으론 값을 가지고 있지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티다.

### 16.3.1 데이터 프로퍼티

- `[[Value]]`: 프로퍼티 키를 통해 접근하면 반환되는 값
- `[[Writable]]`: 프로퍼티 값 변경 가능 여부 (불리언)
- `[[Enumerable]]`: 프로퍼티 열거 가능 여부 (불리언)
- `[[Configurable]]`: 프로퍼티 재정의 가능 여부 (불리언)

### 16.3.2 접근자 프로퍼티

- `[[Get]]`: 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수
- `[[Set]]`: 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수
- `[[Enumerable]]`: 데이터 프로퍼티와 동일
- `[[Configurable]]`: 데이터 프로퍼티와 동일

`getter`, `setter` 함수라고도 부른다.

## 16.4 프로퍼티 정의

> 프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.

프로퍼티 디스크립터 객체의 프로퍼티 각각 생략했을 때의 기본 값

- value, `[[Value]]`: `undefined`
- get, `[[Get]]`: `undefined`
- set, `[[Set]]`: `undefined`
- writable, `[[Writable]]`: `false`
- enumerable, `[[Enumerable]]`: `false`
- configurable, `[[Configurable]]`: `false`

## 16.5 객체 변경 방지

> 객체는 원래 변경 가능한 값이므로 재할당 없이 직접 변경할 수 있다. 즉, 갱신, 삭제, 추가, 프로퍼티 어트리뷰트를 재정의 할 수도 있다. 그래서 객체의 변경을 방지하는 다양한 메서드를 제공한다. 객체의 변경을 메서드들의 강도가 각각 다른데 살펴보자.

- Object.preventExtensions
- Object.seal
- Object.freeze

| 구분           | 메서드                     | 프로퍼티 추가 | 프로퍼티 삭제 | 프로퍼티 값 읽기 | 프로퍼티 값 쓰기 | 프로퍼티 어트리뷰트 재정의 |
| -------------- | -------------------------- | ------------- | ------------- | ---------------- | ---------------- | -------------------------- |
| 객체 확장 금지 | `Object.preventExtensions` | X             | O             | O                | O                | O                          |
| 객체 밀봉      | `Object.seal`              | X             | X             | O                | O                | X                          |
| 객체 동결      | `Object.freeze`            | X             | X             | O                | X                | X                          |

# 17. 생성자 함수에 의한 객체 생성

## 17.1 Object 생성자 함수

```javascript
const person = new Object();
```

다른 string, number, array, boolean들도 생성자 함수를 제공한다.
하지만 리터럴 `{}`을 사용하는 것이 더 간편하다.
그래서 그닥 유용하지 않다고 한다.

## 17.2.3 생성자 함수의 인스턴스 생성 과정

1. 인스턴스 생성과 this 바인딩

암묵적으로 인스턴스가 생성되고, `this`에 바인딩된다.

2. 인스턴스 초기화

생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 `this`에 바인딩되어 있는 인스턴스를 초기화한다.

3. 인스턴스 반환

생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 `this`가 암묵적으로 반환된다.
만약 명시적으로 `return` 문을 명시한다면, `return` 문에 있는 객체가 반환된다.
원래 기본 동작은 `this`를 반환하는 것이라서 다른 객체를 `return` 한다면 기본 동작을 훼손하는 방법이다. 그래서 생성자 함수에서는 `return`문을 반드시 생략해야 한다.

## 17.2.4 `[[Call]]`, `[[Construct]]`

```javascript
function foo() {}

// 일반적인 함수로서 호출: [[Call]]이 호출
foo();

// 생성자 함수로서 호출: [[Construct]]가 호출
new foo();
```

`[[Construct]]`를 갖지 않는 함수 객체를 non-constructor라고 부르고, 객체를 생성자 함수로서 호출할 수 없는 함수를 의미한다.

`[[Call]]`을 가지면 callable이라고 하며 모든 함수 객체는 내부 메서드 `[[Call]]`을 다 가지고 있다.

함수 객체가 모두 `[[Construct]]`를 갖는 것은 아니기 때문에 constructor 일 수도 있고 non-constructor 일 수도 있다.

## 17.2.5 constructor와 non-constructor의 구분

- constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)
- non-constructor: 메서드(ES6 메서드 축약 표현), 화살표 함수

## 17.2.6 new 연산자

> `new` 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 단, `new` 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor여야 한다.
