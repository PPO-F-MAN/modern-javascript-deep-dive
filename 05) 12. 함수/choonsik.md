# 12장 함수

## 1. 함수란?

> 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 **하나의 실행 단위**로 정의한 것

매개 변수 : 함수 내부로 입력을 전달받는 변수
인수 : 입력
반환값 : 출력

함수는 값이며 여러 개 존재할 수 있으므로, 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.

함수는 **함수 정의**를 통해 생성한다.

```js
function add(x, y) {
  return x + y;
}
```

함수는 **함수 호출**을 통해 반환값을 반환한다.

```js
var result = add(2, 5);
```

## 2. 함수를 사용하는 이유

1. 함수는 여러 번 호출할 수 있다.
2. 함수는 실행 시점을 개발자가 결정할 수 있다.
3. **재사용**이 가능하다.

> 코드의 중복을 억제하고 재사용성을 높이는 함수는 **유지보수의 편의성**을 높이고 실수를 줄여 **코드의 신뢰성**을 높이는 효과가 있다.

함수는 객체 타입의 **값**이다. 즉 이름(식별자)을 붙일 수 있다.
적절한 함수 이름을 통해 **코드의 가독성**을 향상시키자

## 3. 함수 리터럴

함수는 **객체 타입의 값**이므로 함수 리터럴로 생성할 수 있다.

```js
var f = function add(x, y) {
  return x + y;
};
```

함수 리터럴의 구성 요소
| 구성 요소 | 설명 |
| - | - |
| 함수 이름 | 함수 이름은 식별자다. 따라서 식별자 네이밍 규칙을 준수해야 한다.<br> 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.<br>함수 이름은 생략할 수 있으며, 이름 유무에 따라 기명/무명(익명)함수라고 부른다. |
| 매개변수 목록 | 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.<br>매개변수 목록은 순서에 의미가 있다.(순서대로 할당)<br>매개변수는 함수 몸체에서 변수와 동일하게 취급되며, 식별자 네이밍 규칙을 준수해야 한다. |
| 함수 몸체 | 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드블록.<br> 함수 호출에 의해 실행된다. |

#### 함수 객체 vs 일반 객체

- 일반 객체는 호출할 수 없지만, 함수는 호출할 수 있다.
- 함수 객체는 고유한 프로퍼티를 갖는다.

### 함수 정의

> 함수 호출 이저에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것

#### 함수 정의 방식

> 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. (이는 `undefined`와 다르다.)
> 따라서 **변수**는 **선언**, **함수**는 **정의**라고 표현하고 있다.

### 함수 선언문

```js
function add(x, y) {
  return x + y;
}
// *undefined

// 함수 참조
console.dir(add); // f add(x, y)

// 함수 호출
console.log(add(2, 5));
```

함수 선언문은 함수 리터럴과 달리 함수 이름을 생략할 수 없다.

\*에서 볼 수 있듯, 함수 선언문은 표현식이 아닌 문이다.
하지만 아래 코드는 동작한다.

```js
var add = function add(x, y) {
  return x + y;
};
console.log(add(2, 5));
```

위 코드가 동작하는 이유는 자바스크립트 엔진이 코드의 문맥에 따라
동일한 `함수 리터럴`을

1. **표현식이 아닌 문**인 `함수 선언문`으로 해석하는 경우
2. **표현식인 문**인 `함수 리터럴 표현식`으로 해석하는 경우

가 있기 때문이다.

- { }은 중의적 표현이다.

  - { }이 단독으로 존재하면 블록문으로 해석
  - { }이 값으로 평가되어야 할 문맥에서 피연산자로 사용되면 객체 리터럴로 해석

- 기명 함수 리터럴은 중의적인 코드다.
  - 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석
  - 기명 함수 리터럴이 값으로 평가되어야 하는 문맥에서는 함수 리터럴 표현식으로 해석

```js
function foo() {
  console.log("foo");
}
foo(); // foo. *함수 선언문으로 해석

(function bar() {
  console.log("bar");
});
bar(); // ReferenceError: bar is not defined. 함수 리터럴 표현식으로 해석
```

\* 에서 foo는 자바스크립트 엔진이 암묵적으로 생성한 식별자다.
자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

사실 \*는 다음과 비슷하게 동작한다.

```js
var add = function add(x, y) {
  return x + y;
};

console.log(add(2, 5));
```

> 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.

### 함수 표현식

> 값의 성질을 갖는 객체를 **일급 객체**라고 하며, 자바스크립트의 함수는 일급 객체다.
> 따라서 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있고, 이러한 정의 방식을 **함수 표현식**이라 한다.

```js
var add = function (x, y) {
  return x + y;
};
```

함수 리터럴의 함수 이름은 일반적으로 생략한다. (익명 함수 표현식)

### 함수 생성 시점과 함수 호이스팅

> 함수 선언문과 함수 표현식은 함수의 생성 시점이 다르다.
>
> - 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
> - 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.

#### 함수 선언문 실행 시점

- 런타임 이전에 함수 객체가 생성되고, 함수 이름과 동일한 식별자에 할당까지 완료된다.
- 함수 호이스팅이 발생한다.
  - 변수 호이스팅과 달리 함수 객체로 초기화가 완료된다.

#### 함수 표현식 실행 시점

- 좌변의 변수는 런타임 이전에 undefined로 초기화된다.
- 함수 표현식의 함수 리터럴은 할당문이 실행되는 시점(런타임)에 평가되어 함수 객체가 된다.
- 변수 호이스팅이 발생한다.

> 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하므로, 더글라스 크락포드는 함수 선언문 대신 함수 표현식을 사용할 것을 권장한다.

### Function 생성자 함수

> 일반적이지도, 바람직하지도 않다. `Function` 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등, 함수 선언문/표현식으로 생성한 함수와 다르게 동작한다.

```js
var add = new Function("x", "y", "return x + y"); // new 연산자가 없어도 동일하다.
```

### 화살표 함수

```js
var add = (x, y) => x + y;
```

> 화살표 함수는 항상 익명 함수로 정의한다. 기존 함수보다 표현도 동작도 간략하다.
>
> - 생성자 함수로 사용 불가
> - 기존 함수와 this 바인딩 방식이 다르다
> - prototype 프로퍼티가 없다.
> - arguments 객체를 생성하지 않는다.

## 4. 함수 호출

### 매개변수와 인수

```js
function add(x, y) {
  return x + y;
}

// 인수 1, 2가 매개변수 x, y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.
var result = add(1, 2);
```

- 매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일하게 취급된다.
  함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 새성되고, 일반 변수와 마찬가지로 `undefined`로 초기화된 후 인수가 순서대로 할당된다.

- 인수가 부족해도 에러가 발생하지 않는다.
  할당되지 않은 매개변수의 값은 `undefined`이다.

- 초과된 인수는 무시된다.
  암묵적으로 `arguments` 객체의 프로퍼티로 보관된다.

### 인수 확인

- 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
- 자바스크립트는 동적 타입 언어로, 매개변수의 타입을 지정할 수 없다.

> 따라서 함수 정의 시 적절한 인수가 전달되었는지 확인할 필요가 있다.
>
> - 타입스크립트를 사용하는 것도 하나의 방법이다.
> - 단축 평가로 기본 값을 할당하는 방법도 있다. (a = a || 0)
> - 매개변수 기본값을 사용해 인수 체크 및 초기화를 할 수 있다. ( function foo(a = 0){...} )

### 매개변수의 최대 개수

> 매개변수는 순서에 의미가 있다. 매개변수의 개수나 순서가 변경되면 유지보수성이 나빠진다.

**이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.**
매개변수는 적을 수록 좋으며, 최대 3개 이상을 넘지 않는 것을 권장한다.
그 이상이 필요하다면 하나의 매개변수를 선언해 객체를 인수로 전달하는 것이 유리하다.

- 객체를 인수로 사용하는 경우 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경쓰지 않아도 된다.
- 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수 효과가 발생하므로 주의해야 한다.

### 반환문

> 함수는 `return` 키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환(return)할 수 있다. (함수 호출은 표현식이다. 함수 호출 표현식은 반환값으로 평가된다.)

- 반환문은 함수 몸체 내부에서만 사용할 수 있다. (전역에서 사용할 수 없다. 예외) Node.js)

#### 반환문의 역할

1. 함수의 실행을 **중단**하고 함수 몸체를 빠져나간다.
2. `return` 키워드 뒤에 오는 표현식을 평가해 반환한다. (표현식이 없을 시 `undefined`)

#### 반환문과 세미콜론

- `return` 키워드와 표현식 사이에 줄바굼이 있을 시 세미콜론이 자동 삽입되어 주의해야 한다.

## 6. 참조에 의한 전달과 외부 상태의 변경

> 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따른다.

### 원시 타입 인수

값 자체가 복사되어 매개변수에 전달되므로 함수 몸체에서 그 값을 변경(재할당을 통한 교체)해도 원본이 훼손되지 않는다.

### 객체 타입 인수

참조 값이 복사되어 매개변수에 전달되므로 함수 몸체에서 그 값을 변경(재할당을 통한 교체)해도 원본이 훼손된다.

- 이 경우 상태 변화를 추적하기 어려워져 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다.
  - 옵저버 패턴 등의 대응이 필요하다.
  - 혹은 객체를 불변 객체로 만들어 사용한다. (객체의 복사본을 새롭게 생성(deep copy)하는 비용)

> **순수 함수**
> 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수.  
> 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 **함수형 프로그래밍**이라 한다.

## 7. 다양한 함수의 형태

### 즉시 실행 함수

> 함수 정의와 동시에 즉시 호출되는 함수. 단 한번만 호출되며 재호출할 수 없다.

```js
// 익명 즉시 실행 함수가 일반적이다.
// 그룹 연산자 내 기명 함수를 쓸 경우 함수 리터럴로 평가되어 즉시 실행 함수를 다시 호출할 수 없게 된다.
(function foo() {
  var a = 3;
  var b = 5;
  return a * b;
})();

foo(); // ReferenceRrror: foo is not defined
```

```
function() { ... } (); // SyntaxError: Function Statements require a function name. 반드시 그룹 연산자로 감싸야 한다. 그룹 연산자의 피연산자는 값으로 평가므로 함수 리터럴로 평가되어 함수 객체가 생성된다.

function foo() { ... } (); // SyntaxError: Unexpected token ')' // 중괄호 뒤에 ";"이 암묵적으로 추가된다.
```

#### 가능한 방식들

```
// 추천
(function () {
  ...
}());

(function () {
  ...
})();

!function () {
  ...
}();

+function () {
  ...
}();
```

> 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수 있다. 즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수 있는 변수/함수 이름의 충돌을 방지할 수 있다.

### 재귀 함수

> 함수가 자기 자신을 호출하는 것을 **재귀 호출**이라 한다.
> **재귀 함수**는 재귀 호출을 수행하는 함수를 말한다.

```js
// 반복문
function countdown(n) {
  for (var i = n; i >= 0; i--) console.log(i);
}

countdown(10);

// 재귀 함수
function countdown(n) {
  if (n < 0) return;
  console.log(n);
  countdown(n - 1); // 재귀 호출
}

countdown(10);
```

- 함수 내부에서는 함수 이름을 사용해 재귀 호출이 가능하다.
- 함수 외부에서는 함수를 가리키는 식별자로 호출해야 한다.

#### 탈출 조건

재귀 함수는 재귀 호출을 멈출 수 있는 **탈출 조건**을 반드시 만들어야 한다.
**탈출 조건**이 없을 경우 `스택 오버플로 에러`가 발생한다.

> 재귀 함수는 반복되는 처리를 반복문 없이 구현할 수 있지만, `무한 반복`에 빠질 수 있고 이로 인한 `스택 오버플로 에러`를 발생시킬 수 있으므로 주의해야 한다.  
> 재귀 함수가 직관적으로 이해하기 쉬운 경우 한정적으로 사용하자

### 중첩 함수

> 함수 내부에 정의된 함수를 **중첩 함수** 또는 **내부 함수**라고 한다.  
> **중첩 함수**를 포함하는 함수는 **외부 함수**라고 부르며, 중첩 함수는 외부 함수 내부에서만 호출할 수 있다. (ES6부터는 `if 문`이나 `for 문` 등의 코드 블록 내에서도 (함수 선언문을) 정의할 수 있지만, 바람직하지 않다.)
> 일반적으로 **중첩 함수**는 자신을 포함하는 **외부 함수**를 돕는 **헬퍼 함수** 역할을 한다.

```js
function outer() {
  var x = 1;

  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수 참조
    console.log(x + y);
  }

  inner();
}

outer();
```

### 콜백 함수

> 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 **콜백 함수**라고 하며, 매개 변수를 통해 함수 외부에서 콜백 함수를 전달받은 함수를 **고차 함수**라고 한다.  
> **콜백 함수**는 **고차 함수**에 전달되어 **헬퍼 함수**의 역할을 한다.  
> **고차 함수**는 **콜백 함수**를 자신의 일부분으로 **합성**한다.

```js
function repeat(n, f) {
  for (var i = 0; i < n; i++) f(i);
}

var logAll = function (i) {
  console.log(i);
};

repeat(5, logAll);

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

repeat(5, logOdds);
```

> 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.  
> 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.
>
> - 콜백 함수는 함수형 프로그래밍 패러다임, 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등)에 활용되는 중요한 패턴이다.
> - 콜백 함수는 비동기 처리뿐 아니라 배열 고차 함수(`map`, `filter`, `reduce`)에서도 사용된다.

### 순수 함수와 비순수 함수

#### 순수 함수

- 어떤 외부 상태에 의존하지도 변경하지도 않는, 부수 효과가 없는 함수
- 동일한 인수가 전달되면 동일한 값을 반환
- 최소 하나 이상의 인수를 전달 받는다. (그렇지 않으면 상수)
- 인수의 불변성을 유지한다.

#### 비순수 함수

- 외부 상태에 의존하거나 외부 상태를 변경하는, 부수 효과가 있는 함수
- 함수 외부 상태(전연 변수, 서버 데이터, 파일, Console, DOM)에 따라 반환 값이 달라진다.
- 인수를 전달받지 않고 함수 내부에서 외부 상태를 직접 참조하는 경우
- 상태 변화를 추적하지 어려우며 코드의 복잡성을 증가시킨다.

#### 함수형 프로그래밍

- 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임
- 로직 내 조건문, 반복문을 제거해 복잡성 해결 (가독성)
- 변수 사용 억제, 생명주기 최소화로 상태 변경을 피해 오류를 최소화 (오류의 근본적 원인)
