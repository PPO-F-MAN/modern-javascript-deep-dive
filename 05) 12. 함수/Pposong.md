# 12. 함수

## 12장 함수

### 12.1 함수란?

프로그래밍 언어의 **함수**는 일련의 과정을 문(`statement`)로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.

함수 내부로 입력을 전달받는 변수를 매개변수(`parameter`), 입력을 인수(`argument`), 출력을 반환값(return value)이라 한다.

함수는 함수 정의(`function definition`)를 통해 생성한다.

```ts
// 함수 정의
function add(x: number, y: number): number {
  return x + y;
}
```

함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고, 실행 결과, 즉 반환값을 반환한다.

```ts
// 함수 호출
const result = add(2, 5);

console.log(result);
```

### 12.2 함수를 사용하는 이유

- 유지보수 비용의 감소
- 코드의 신뢰성 제고
- 코드의 가독성 향상

함수를 사용함으로써 코드의 중복을 억제하고 재사용성을 높인다.

따라서 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높인다.

또한 함수도 객체이기 때문에 이름을 가진다.

적절한 함수 이름은 코드의 가독성을 향상시킨다.

### 13.3 함수 리터럴

```ts
// 변수에 함수 리터럴을 할당
const f = function add(x: number, y: number): number {
  return x + y;
}
```

함수는 객체지만 일반 객체와는 다르다.

일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.

그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.

### 12.4 함수 정의

함수를 정의하는 방법에는 4가지가 있다.

#### 12.4.1 함수 선언문

```ts
function add(x: number, y: number): number {
  return x + y;
}
```

함수 선언문은 표현식이 아닌 문이다.
따라서 완료 값 undefined가 출력된다.

그리고 함수 선언문은 함수 이름을 생략할 수 없다.

> 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

#### 12.4.2 함수 표현식

```ts
const add = function(x: number, y: number): number {
  return x + y;
}
```

함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다.

함수 리터럴의 함수 이름은 생략할 수 있다.

#### 12.4.3 함수 생성 시점과 함수 호이스팅

함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다. 그러나 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.

함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생하기 때문이다.

#### 12.4.3 Function 생성자 함수

```ts
const add = new Function('x', 'y', 'return x + y');
```

이 방법은 일반적이지 않으며 바람직하지도 않다.

Function 생성자로 생성한 함수는 클로저를 생성하지 않는 등 다른 방법으로 생성한 함수와 다르게 동작한다.

#### 12.4.4 화살표 함수(ES6)

```ts
const add = (x: number, y: number): number => x + y;
```

화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고 prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.

### 12.5 함수 호출

#### 12.5.1 매개변수와 인수

매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일하게 취급된다.

함수가 호출될 때마다 매개변수는 이와 같은 단계를 거친다.

1. 함수 호출을 통해 인수 전달
2. 매개변수가 undefined로 초기화됨
3. 인수가 순서대로 매개변수에 할당됨

매개변수보다 인수가 더 많은 경우 초과된 인수는 무시된다.

그러나 버려지는 것이 아니라 arguments 객체의 프로퍼티로 보관된다.

#### 12.5.2 인수 확인

함수 내부에서 적절한 인수가 전달되었는지 확인하더라도 부적절한 호출을 사전에 방지할 수는 없고, 에러는 런타임에 발생하게 된다.

ES6에 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.

```ts
function add(a: number = 0, b: number = 0, c: number = 0): number {
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0
```

#### 12.5.3 매개변수의 최대 개수

이 부분은 클린 코드에서 설명한 것으로 대체한다.

매개변수의 개수를 `최대 3개!` 이렇게 제한하는 것은 교조주의에 빠지게 할 뿐이라는 것을 기억하자.

[Clean Code 3. 함수](https://velog.io/@dnr6054/Clean-Code-3-%ED%95%A8%EC%88%98#%ED%95%A8%EC%88%98-%EC%9D%B8%EC%88%98)

#### 12.5.4 반환문

반환문은 두 가지 역할을 한다.

첫째, 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.

둘째, 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. 명시적으로 지정하지 않으면 undefined가 반환된다.

### 12.6 참조에 의한 전달과 외부 상태의 변경

원시값은 값에 의한 전달, 객체는 참조에 의한 전달 방식으로 동작한다.

매개변수도 변수와 동일하게 취급되므로 위 방식을 그대로 따른다.

이러한 문제의 해결방법 중 하나는 객체를 불변 객체로 만들어 사용하는 것이다.

이를 통해 객체의 상태 변경을 원천봉쇄하고, 상태 변경이 필요한 경우에는 객체의 방어적 복사를 통해 원본 객체를 완전히 복제, 즉 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다.

### 12.7 다양한 함수의 형태

#### 12.7.1 즉시 실행 함수

즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없다.

```ts
(function() {
  var a = 3;
  var b = 5;
  return a * b;
})();
```

즉시 실행 함수는 익명 함수를 사용하는 것이 일반적이다.

이름을 쓴다고 해도 외부에서 호출할 수는 없다.

그리고 무조건 소괄호로 묶어줘야 한다.

#### 12.7.2 재귀 함수

재귀함수는 Stack Overflow 에러를 발생시킬 수 있으므로 반복문을 사용하는 것보다 재귀함수를 사용하는 편이 더 이해하기 쉬울 때에만 한정적으로 사용하는 것이 바람직하다.

#### 12.7.3 중첩 함수

ES6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다.

그러나 호이스팅으로 인해 혼란이 생길 수 있으므로 if문이나 for문 등의 코드 블록에서 함수 선언문을 통해 함수를 정의하는 것은 바람직하지 않다.

#### 12.7.4 콜백 함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차함수라고 한다.

#### 12.7.5 순수 함수와 비순수 함수

어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수라고 한다.
